% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/archR.R, R/archR_main.R
\docType{package}
\name{archR}
\alias{archR}
\title{archR: A package for de novo discovery of different sequence architectures 
with characteristic combination(s) of sequence elements (motifs) or 
nucleotide compositions.}
\usage{
archR(
  config,
  seqs_ohe_mat,
  seqs_raw,
  seqs_pos = NULL,
  threshold_itr = 3,
  set_parsimony = c(FALSE, FALSE, FALSE),
  set_ocollation = c(TRUE, FALSE, FALSE),
  fresh = TRUE,
  use_oc = NULL,
  o_dir = NULL
)
}
\arguments{
\item{config}{archR configuration object as returned by
\code{\link{archR_set_config}}. This is a required argument.}

\item{seqs_ohe_mat}{A matrix of one-hot encoded sequences with sequences 
along columns. This is a required argument.}

\item{seqs_raw}{A \code{\link{Biostrings::DNAStringSet}} object. The FASTA 
sequences as a DNAStringSet object. This argument required argument.}

\item{seqs_pos}{Vector. Specify the tick labels for sequence positions.
Default is NULL.}

\item{threshold_itr}{Numeric. Specify the number of iterations to perform.
Default is 3.}

\item{set_parsimony}{Logical vector. Specify if model selection by
cross-validation should prefer parsimonious solutions. Not required when
stability-based model selection is chosen. Length of the vector should match
number of iterations specified in 'threshold_itr' argument. TRUE denotes 
parsimony is followed, FALSE otherwise.}

\item{set_ocollation}{Logical vector. Specify for every iteration of archR
if collation of clusters from outer chunks should be performed. TRUE denotes
clusters are collated, FALSE otherwise.}

\item{fresh}{Logical. Specify if this is (not) a fresh run. Because
archR enables checkpointing, it is possible to perform additional iterations
upon clusters from an existing archR result (or a checkpoint) object. 
See 'use_oc' argument. For example, when processing a set of FASTA sequences,
if an earlier call to archR performed two iterations, and now you wish to 
perform a third, the arguments `fresh` and `use_oc` can be used. Simply set 
`fresh` to FALSE and assign the sequence clusters from iteration two from 
the earlier result to `use_oc`. As of v0.1.3, with this setting, archR 
returns a new result object as if the additional iteration performed is the 
only iteration.}

\item{use_oc}{List. Clusters to be further processed with archR. These can 
be from a previous archR result (in which case use 
archRresult$clustSol$clusters), or simply clusters from any other method.
Warning: This has not been rigorously tested yet (v0.1.3).}

\item{o_dir}{Character. Specify the output directory with its path. archR
will create this directory. If a directory with the given name exists at the
given location, archR will add a suffix to the directory name. This
change is reported to the user. Default is NULL. When NULL, just the result
is returned, and no plots or checkpoints or result is written to disk.}
}
\value{
A nested list of elements as follows:
\describe{
\item{seqsClustLabels}{A list with cluster labels for all sequences per 
iteration of archR. The cluster labels as stored as characters.}

\item{clustBasisVectors}{A list with information on NMF basis vectors per 
iteration of archR. Per iteration, there are two variables `nBasisVectors` 
storing the number of basis vectors after model selection,
and `basisVectors`, a matrix storing the basis vectors themselves. 
Dimensions of the `basisVectors` matrix are 4*L x nBasisVectors 
(mononucleotide case) or 16*L x nBasisVectors (dinucleotide case).}
 
\item{clustSol}{The clustering solution obtained upon processing the raw 
clusters from the last iteration of archR's result. This is handled 
internally by the function \code{\link{collate_archR_result}} using the
default setting of Euclidean distance and ward.D linkage hierarchical 
clustering.}
 
\item{rawSeqs}{The input sequences as a DNAStringSet object.}

\item{timeInfo}{Stores the time taken (in minutes) for processing each 
iteration. This element is added only if `time` flag is set to TRUE in 
config.}

\item{config}{The configuration used for processing.}
\item{call}{The function call itself.}
}
}
\description{
Given a set of DNA sequences, \code{archR} enables unsupervised 
discovery of _de novo_ clusters with characteristic sequence architectures 
characterized by position-specific motifs or composition of stretches of 
nucleotides, e.g., CG-richness, etc.

Call this function to process a data set using archR.
}
\details{
The archR package provides three categories of important functions:
related to data preparation and manipulation, performing non-negative matrix
factorization, performing clustering, and visualization-related functions.
}
\section{Functions for data preparation and manipulation}{

\itemize{
\item \code{\link{prepare_data_from_FASTA}}
\item \code{\link{get_one_hot_encoded_seqs}}
}
}

\section{Functions for visualizations}{

\itemize{
\item \code{\link{plot_ggseqlogo}}
\item \code{\link{plot_ggheatmap}}
\item \code{\link{viz_basis_vectors_as_heatmap}}
\item \code{\link{viz_basis_vectors_as_seqlogo}}
\item \code{\link{viz_basis_vectors_in_combined_heatmaps_seqlogos}}
\item \code{\link{plot_arch_for_clusters}}
plot_ggseqlogo_of_seqs
\item \code{\link{viz_seqs_as_acgt_mat_from_seqs}}
}
}

\examples{

fname <- system.file("extdata", "example_data.fa", 
                        package = "archR", mustWork = TRUE)

# Specifying 'dinuc' generates dinucleotide features
inputSeqsMat <- archR::prepare_data_from_FASTA(fasta_fname = fname,
    sinuc_or_dinuc = "dinuc")

inputSeqsRaw <- archR::prepare_data_from_FASTA(fasta_fname = fname, 
    raw_seq = TRUE)

# Set archR configuration
archRconfig <- archR::archR_set_config(
    parallelize = TRUE,
    n_cores = 2,
    n_iterations = 100,
    k_min = 1,
    k_max = 20,
    mod_sel_type = "stability",
    tol = 10^-4,
    bound = 10^-8,
    inner_chunk_size = 100,
    flags = list(debug = TRUE, time = TRUE, verbose = TRUE,
        plot = FALSE)
)

# Run archR 
archRresult <- archR::archR(config = archRconfig,
                          seqs_ohe_mat = inputSeqsMat,
                          seqs_raw = inputSeqsRaw,
                          seqs_pos = seq(1,100,by=1),
                          threshold_itr = 2)

 
}
