---
title: "Example usage of _archR_ on simulated DNA sequences"
author: "Sarvesh Nikumbh"
date: "`r Sys.Date()`"
output:
  pdf_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
vignette: >
  %\VignetteIndexEntry{Example usage of archR}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

```

# Introduction
_archR_ is a non-negative matrix factorization (NMF)-based unsupervised 
learning approach for identifying different core promoter sequence 
architectures. 
_archR_ implements an algorithm based on chunking and iterative 
processing. 
While matrix factorization-based applications are known to scale poorly for 
large amounts of data, archR's algorithm enables scalable 
processing of large number of sequences.
A notable advantage of archR is that the sequence motifs -- the lengths and 
positional specificities of individual motifs, and complex inter-relationships 
where multiple motifs are at play in tandem, all are simultaneously inferred 
from the data.
To our knowledge, this is a novel application of NMF on biological sequence data
 capable of simultaneously discovering the sequence motifs and their positions.
For a more detailed discussion, see preprint/publication [TODO: link here].


This vignette demonstrates _archR_'s usage with the help of a synthetic DNA 
sequences data set. 
Please refer to the paper (TODO: cite paper/preprint) for a detailed description of
_archR_'s algorithm.
The paper also discusses the various parameters and their settings.
For completeness, the following section gives a brief overview of the algorithm.

# _archR_'s algorithm
_archR_ implements a chunking-based iterative procedure. Further details to follow.

# Installation
_archR_ is currently made available via GitHub, thus, you can use the following procedure
for installing _archR_.
```{r archR-install, echo=TRUE, eval=FALSE}
install.packages("remotes")
remotes::install_github("snikumbh/archR", build_vignettes = TRUE)
 
```
In case of any errors, please consider looking up [https://github.com/snikumbh/archR](https://github.com/snikumbh/archR). 
If none of the already noted points with regards to troubleshooting _archR_'s installation help, 
please file a [new issue](https://github.com/snikumbh/archR/issues/new).



# Working with _archR_
```{r setup-two, echo=TRUE}
# Load archR
library(archR)
library(Biostrings, quietly = TRUE)


# Set seed for reproducibility
seed_val <- 11992288
set.seed(seed_val)

```

## Synthetic data explained

In order to demonstrate the efficacy of _archR_, we use _archR_ to cluster DNA 
sequences in a synthetic data set which was generated as follows. 
A set of 200 simulated DNA sequences was generated, each 100 nucleotides long 
and with uniform probability for all nucleotides. 
These sequences have four clusters in them, each with 50 sequences. 
The profiles of the four clusters are:


| Cluster | Characteristic Motifs | Motif Occurrence Position | #Sequences 
|----------|:----------|:----------|----------
| A | Dinucleotide repeat `AT` | every 10 nt | 50
| B | `GATTACA` | 40 | 50
|   | `GAGAG` | 60 |
| C | `GAGAG` | 60 | 50
| D | `GAGAG` | 80 | 50
|   | `TCAT`  | 40 |
<!-- ----------|----------|----------|----------| -->

All the motifs across the clusters were planted with a mutation rate of 0.


## Input and feature representation

We use one-hot encoding to represent the dinucleotide profiles of each sequence 
in the data set.
_archR_ provides functions to read input from (a) a FASTA file, and 
(b) `Biostrings::DNAStringSet` object.

### Reading input as FASTA file
The function `archR::prepare_data_from_FASTA()` enables one-hot-encoding the DNA sequences in 
the given FASTA file.
The one-hot-encoded sequences are returned as a sparse matrix with as many columns 
as the number of sequences in the FASTA file and (#sequences x $4^{2}$) rows 
when dinucleotide profiles is selected. The number of rows will be (#sequences x $4$) when 
mononucleotide profiles is selected. See the `sinuc_or_dinuc` argument.


Upon setting the logical argument `rawSeq` to `TRUE`, the function returns the raw 
sequences as a `Biostrings::DNAStringSet` object, with `FALSE` it returns the column-wise 
one-hot encoded representation as noted above.
When `rawSeq` is `TRUE`, `sinuc_or_dinuc` argument is ignored.

```{r load-example-data, echo=TRUE}
# Creation of one-hot encoded data matrix from FASTA file
inputFastaFilename <- system.file("extdata", "example_data.fa", 
                                  package = "archR", 
                                  mustWork = TRUE)

# Specifying `dinuc` generates dinucleotide features
inputSeqsMat <- archR::prepare_data_from_FASTA(inputFastaFilename,
                                                  sinuc_or_dinuc = "dinuc")

inputSeqsRaw <- archR::prepare_data_from_FASTA(inputFastaFilename, 
                                               rawSeq = TRUE)

nSeqs <- length(inputSeqsRaw)
positions <- seq(1, Biostrings::width(inputSeqsRaw[1]))
sinuc <- Biostrings::DNA_BASES

```


### Reading input as a DNAStringSet object
If you already have a `BioStrings::DNAStringSet` object, you can use the 
`get_one_hot_encoded_seqs()` function which directly accepts a `DNAStringSet` 
object.

```{r load-example-data-2, echo=TRUE, eval=TRUE}
# Creation of one-hot encoded data matrix from a DNAStringSet object
inputSeqs_direct <- archR::get_one_hot_encoded_seqs(inputSeqsRaw, 
                                                  sinuc_or_dinuc = "dinuc")
identical(inputSeqs_direct, inputSeqsMat)
```


## Visualize input sequences as an image

```{r plot-seqs, echo=TRUE, fig.height=6, fig.width=5}
# Visualize the sequences in a image matrix where the DNA bases are assigned fixed
# colors

archR::viz_seqs_as_acgt_mat_from_seqs(as.character(inputSeqsRaw), 
                          position_labels = positions, 
                          savefilename = NULL
                          )

```


## Calling _archR_


```{r setup-archR-config-call, echo=TRUE}
# Set archR configuration
archRconfig <- archR::archRSetConfig(
        parallelize = TRUE,
        nCores = 4,
        nIterationsUse = 100,
        kMin = 1,
        kMax = 20,
        modSelType = "stability",
        tol = 10^-4,
        bound = 10^-8,
        innerChunkSize = 100,
        flags = list(debugFlag = FALSE, timeFlag = TRUE, verboseFlag = TRUE,
                     plotVerboseFlag = FALSE)
)

# Call/Run archR
perform_iters <- 2
archRresult <- archR::archR(config = archRconfig,
                               seqsMat = inputSeqsMat,
                               seqsRaw = inputSeqsRaw,
                               seqsPositions = positions,
                               thresholdItr = perform_iters)

```



## Understanding the result object from _archR_

In the version `r packageVersion("archR")`, _archR_ naively returns a result object 
which is a nested list.
The list elements include: 
(a) the sequence cluster labels per iteration 
[`seqsClustLabels`]; 
(b) the collection of NMF basis vectors per iteration [`clustBasisVectors`]: each 
is a list of two elements `nBasisVectors` and `basisVectors`.
(c) the raw sequences provided [`rawSeqs`]; 
(d) the configuration setting [`config`]; and 
(e) the call itself [`call`].



### NMF basis vectors
_archR_ stores the NMF basis vectors corresponding to each cluster in 
every iteration in the variable `clustBasisVectors`. `clustBasisVectors` 
is a numbered list corresponding to the number of iterations performed.
This is then again a list holding two pieces of information: the number of 
basis vectors (`nBasisVectors`) and the basis vectors 
(`basisVectors`).

```{r archR-result-clust-factors}

# Basis vectors at iteration 2
archRresult$clustBasisVectors[[2]]$nBasisVectors
dim(archRresult$clustBasisVectors[[2]]$basisVectors)
head(archRresult$clustBasisVectors[[2]]$basisVectors)
```


## Visualize results from _archR_

In this section we demonstrate how to visualize results from _archR_. 
One can visualize the NMF basis vectors as well as the sequence clusters.

<!-- ### Visualizing NMF basis vectors at any iteration -->
<!-- We can visualize the basis vectors corresponding to each cluster at any  -->
<!-- iteration.  -->
<!-- These per-iteration basis vectors are available from the `archRresult` object  -->
<!-- (see above Section). -->

<!-- ```{r viz-BV-1, echo=TRUE, fig.height=2, fig.width=25} -->
<!-- archR::viz_basis_vectors_as_seqlogo( -->
<!--     archRresult$clustBasisVectors[[1]]$basisVectors, -->
<!--     position_labels = positions, -->
<!--     plotMethod = "bits" -->
<!-- ) -->

<!-- archR::viz_basis_vectors_as_heatmap( -->
<!--     archRresult$clustBasisVectors[[1]]$basisVectors, -->
<!--     position_labels = positions) -->
<!-- ``` -->


<!-- ```{r viz-BV-2, fig.height=2, fig.width=25, echo=TRUE} -->
<!-- archR::viz_basis_vectors_as_seqlogo( -->
<!--     archRresult$clustBasisVectors[[2]]$basisVectors, -->
<!--     position_labels = positions, -->
<!--     plotMethod = "bits" -->
<!-- ) -->

<!-- archR::viz_basis_vectors_as_heatmap( -->
<!--   archRresult$clustBasisVectors[[2]]$basisVectors, -->
<!--   position_labels = positions) -->
<!-- ``` -->



<!-- ```{r visualize-basis-vectors-combined, echo=TRUE, fig.height=4, fig.width=25} -->
<!-- archR::viz_basis_vectors_in_combined_heatmaps_seqlogos( -->
<!--   archRresult$clustBasisVectors[[2]]$basisVectors, -->
<!--   position_labels = positions, plotMethod = "bits", savePDFfilename = NULL -->
<!-- ) -->
<!-- ``` -->
<!-- The `plotMethod` argument to functions producing sequence logos is supplied to  -->
<!-- the call to `ggseqlogo`. The possible values are `custom`, `bits`. -->


The clustered output from _archR_ can again be visualized as a matrix. 
Simply sort the sequences based on the cluster labels assigned to them and call 
`archR::viz_seqs_as_acgt_mat_from_seqs` with the sorted order as shown.
```{r visualize-clusters-itr1, echo=TRUE, fig.height=6, fig.width=5, fig.cap="Figure: Result at iteration 1", eval=TRUE}

itr <- 1
seqsClustLabels <- archRresult$seqsClustLabels[[itr]]
sorted_order <- sort(seqsClustLabels, index.return = TRUE)


archR::viz_seqs_as_acgt_mat_from_seqs(as.character(inputSeqsRaw[sorted_order$ix]), 
                         position_labels = positions,
                         savefilename = NULL)
```

```{r visualize-clusters-itr2, echo=TRUE, fig.height=6, fig.width=5, fig.cap="Figure: Result at iteration 2", eval=TRUE}

itr <- 2
seqsClustLabels <- archRresult$seqsClustLabels[[itr]]
sorted_order <- sort(seqsClustLabels, index.return = TRUE)


archR::viz_seqs_as_acgt_mat_from_seqs(as.character(inputSeqsRaw[sorted_order$ix]), 
                         position_labels = positions,
                         savefilename = NULL)
```
<!-- ![_archR_ result on example data w/ clusters](./archR-result-example-data.png) -->


<!-- This output in Figure 1 was generated by performing 100 bootstrapped iterations,  -->
<!-- parallely by setting the following configuration parameters to _archR_: -->
<!-- `nIterations = 100, nCoresUse = 4, parallelize = TRUE`. -->

# Conclusion

_archR_ can detect _de novo_ sequence features and simultaneously identify the 
complex interactions of different features together with their positional 
specificities.

Note that the sequence architectures identified by archR have no limitations 
due to the size of the motifs or gaps in them, distance between motifs, compositional
and positional variations in the individual motifs and their effects on the 
complex interactions, and number of motifs involved in any interaction.
<!-- It is advisable to perform a large number of bootstrapped iterations for NMF in  -->
<!-- _archR_.  -->
<!-- This potentially affects the computation time of _archR_.  -->
<!-- But being an  -->
<!-- embarrasingly parallelizable case, this issue is alleviated.  -->
<!-- There are already  -->
<!-- provisions in _archR_ to choose parallelization for speeding up computations. -->

# Session Info
```{r session_info, include=TRUE, echo=TRUE, results='markup'}
sessionInfo()
```
